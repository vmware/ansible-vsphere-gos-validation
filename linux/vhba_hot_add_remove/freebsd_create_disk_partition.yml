# Copyright 2023 VMware, Inc.
# SPDX-License-Identifier: BSD-2-Clause
---
# Description:
#   Create and format 1 new partition on a disk
# Parameters:
#   disk_name: The disk name to be formatted and create partition
#   partition_fstype: Create filesystem on new partition, which could be ext4, xfs
#                         or btrfs, etc. The default filesystem is ext4.
# Return:
#   partition_name: The disk partition name
#   partition_device_path: The disk partition device path
#
- name: "Initialize disk partition name and device path"
  ansible.builtin.set_fact:
    partition_name: ""
    partition_device_path: ""
    partition_uuid: ""

- name: "Set default partition filesystem to ufs"
  ansible.builtin.set_fact:
    partition_fstype: "ufs"
  when: >
    partition_fstype is undefined or
    not partition_fstype

- name: "Filesystem {{ partition_fstype }} is not supported"
  ansible.builtin.fail:
    msg: >-
      Guest OS doesn't support filesystem {{ partition_fstype }}, so it can't
      create partition with filesystem {{ partition_fstype }} on disk {{ disk_name }}
  when: partition_fstype is not in ['ufs', 'zfs']

- name: "Create partition table on disk {{ disk_name }}"
  ansible.builtin.command: gpart create -s GPT {{ disk_name }}
  delegate_to: "{{ vm_guest_ip }}"

- name: "Create 1 partition on disk {{ disk_name }}"
  ansible.builtin.shell: gpart add -t freebsd-{{ partition_fstype }} {{ disk_name }}
  delegate_to: "{{ vm_guest_ip }}"

- name: "Show partition table on disk {{ disk_name }}"
  ansible.builtin.command: gpart show {{ disk_name }}
  delegate_to: "{{ vm_guest_ip }}"

- name: "Set fact of partition name"
  ansible.builtin.set_fact:
    partition_name: "{{ disk_name }}p1"

- name: "Set fact of partition device path"
  ansible.builtin.set_fact:
    partition_device_path: "/dev/{{ partition_name }}"

# Hit issue for command 'newfs' in FreeBSD 32bit. rebooting will be workaround.
# The disks maybe exchanged after reboot
- name: "Set boot disk for FreeBSD 32 bit"
  when:
    - guest_os_bit == "32-bit"
    - add_new_controller is defined and add_new_controller
  block:
    - name: "Initialize the fact of device list before reboot and after reboot"
      ansible.builtin.set_fact:
        guest_device_list_before_reboot: []
        guest_device_list_after_reboot: []

    - name: "Get block device list before reboot"
      ansible.builtin.shell: "/tmp/lsblk.sh -d | grep -v SIZE | grep -v cd0"
      delegate_to: "{{ vm_guest_ip }}"
      changed_when: false
      register: lsblk_result

    - name: "Set the fact of block device list before reboot"
      ansible.builtin.set_fact:
        guest_device_list_before_reboot: >
          {{  
              guest_device_list_before_reboot | union([
                dict(['name', 'size', 'model'] |
                      zip_longest(item.split(None, maxsplit=2), fillvalue=''))
              ])
          }}
      with_items: "{{ lsblk_result.stdout_lines }}"

    - name: "Boot order may be changed after hot-add disk to new controller for OS with BIOS firmware"
      ansible.builtin.debug:
        msg:
          - "The disk boot order may be changed after hot-add new disk which causes failure of powering on VM."
          - "Specify the boot disk as workaround. "

    - include_tasks: ../../common/vm_set_boot_options.yml
      vars:
        boot_hdd_name: "Hard disk 1"
        boot_order_list:
          - disk

    - name: "Reboot guest OS to check file content again"
      include_tasks: ../utils/reboot.yml

    - name: "Get block device list after reboot"
      ansible.builtin.shell: "/tmp/lsblk.sh -d | grep -v SIZE | grep -v cd0"
      delegate_to: "{{ vm_guest_ip }}"
      changed_when: false
      register: lsblk_result

    - name: "Set the fact of block device list after reboot"
      ansible.builtin.set_fact:
        guest_device_list_after_reboot: >
          {{  
              guest_device_list_after_reboot | union([
                dict(['name', 'size', 'model'] |
                      zip_longest(item.split(None, maxsplit=2), fillvalue=''))
              ])
          }}
      with_items: "{{ lsblk_result.stdout_lines }}"

    - name: "Set fact of changed disk list after reboot"
      ansible.builtin.set_fact:
        guest_disk_changed_list: "{{ guest_device_list_before_reboot | difference(guest_device_list_after_reboot) }}"

    - name: "Exchange disk name between boot disk and new disk if it's changed after reboot"
      when: guest_disk_changed_list | length == 2
      block:
        - name: "Set fact of new disk info after it's changed"
          ansible.builtin.set_fact:
            new_guest_disk_info: >
              {%- if item.size == '1.0G' -%}{{ item }}
              {%- else -%}{{ new_guest_disk_info }}
              {%- endif -%}
          with_list: "{{ guest_device_list_after_reboot }}"

        - name: "Print new disk in guest OS after it'changed"
          ansible.builtin.debug: var=new_guest_disk_info
        
        - name: "Change fact of boot disk info before hot add"
          ansible.builtin.set_fact:
            guest_disk_list_before_hotadd: "{{ guest_device_list_after_reboot | difference([new_guest_disk_info]) }}"

        - name: "Reset fact of disk name, partition name and device path"
          ansible.builtin.set_fact:
            disk_name: "{{ new_guest_disk_info.name }}"
            partition_name: "{{ new_guest_disk_info.name }}p1"
            partition_device_path: "/dev/{{ new_guest_disk_info.name }}p1"

- name: "Create and check {{ partition_fstype }} filesystem on partition {{ partition_device_path }}"
  ansible.builtin.shell: "newfs -EU {{ partition_device_path }} && sleep 5 && fstyp {{ partition_device_path }}"
  delegate_to: "{{ vm_guest_ip }}"
  ignore_errors: true
  register: partition_result
  retries: 5
  delay: 2
  until:
    - partition_result is defined
    - partition_result.rc is defined
    - partition_result.rc == 0

- name: "Get disk partition info"
  include_tasks: ../utils/freebsd_get_partition_info.yml
  vars:
    disk_partition_name: "{{ partition_name }}"

- name: "Set the fact of partition {{ partition_device_path }} UUID"
  ansible.builtin.set_fact:
    partition_uuid: "{{ disk_partition_info.config.rawuuid }}"
  when: disk_partition_info.config.rawuuid | default('')

- name: "Check the UUID of partition {{ partition_device_path }}"
  ansible.builtin.assert:
    that:
      - partition_uuid
    fail_msg: "Failed to get UUID of partition {{ partition_device_path }}"

- name: "Print the new disk partition name, UUID, device path, and filesystem"
  ansible.builtin.debug:
    msg:
      - "The new disk partition name: {{ partition_name }}"
      - "The new disk partition UUID: {{ partition_uuid }}"
      - "The new disk partition device path: {{ partition_device_path }}"
      - "The new disk partition filesystem: {{ partition_fstype }}"
